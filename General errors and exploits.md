### Classic Reentrancy
This vulnerability happens when, at some point during a function call, the user/attacker is called by the function (for example, through a native token transfer or a token contract with a hook) and the function doesn't follow the checks, effects, interactions pattern (CEI). Attackers can then either call the function again or another function in the protocol, for example, transfer their balance multiple times if the balance is  set to 0 only after the token is transferred to the withdrawing user. To mitigate this, add a `nonReentrant` modifier and/or follow the checks, effects, and interaction pattern.

[Example](https://solodit.cyfrin.io/issues/h-2-adversary-can-reenter-takeoverdebt-during-liquidation-to-steal-vault-funds-sherlock-real-wagmi-2-git)
[Further Reading](https://www.cyfrin.io/glossary/reentrancy)

### Read only Reentrancy
This exploit is similar to the classic reentrancy, but concerns read-only functions. The problem here is that a certain value is modified after an interaction happens, so that any function that relies on the un-updated value will receive incorrect data when getting it, for example, a smaller total supply. To mitigate this, add a `nonReentrant` modifier and/or follow the checks, effects, and interaction pattern.

[Example](https://solodit.cyfrin.io/issues/m-3-read-only-reentrancy-in-bondfixedtermteller-sherlock-bond-bond-protocol-git)
### Unbound arrays
An unbound array where any user can add one or multiple entries through some protocol function can be filled with an extreme amount of entries either during regular operations or on purpose by an attacker, which will cause any iteration over the array to exceed the block gas limit and cause a DOS. To mitigate this, use different storage types or limit entries to the array in some way.

[Example](https://solodit.cyfrin.io/issues/m-05-attacker-can-partially-dos-l1-operations-in-stakingmanager-by-making-huge-number-of-deposits-code4rena-kinetiq-kinetiq-git)

### Replay attack
The same signed transaction can be repeated multiple times when no user-specific nonce is used in the message. This can cause unwanted transfers of user or protocol funds that are potentially not reversible. To mitigate this, simply add an increasing user-specific nonce to the signed message to make sure each message is only used once
[Example](https://solodit.cyfrin.io/issues/m-3-signature-replay-attack-possible-on-updateworkerdeploymentconfigwithsig-in-blueprintcoresol-which-leads-to-users-lose-the-funds-sherlock-crestal-network-git)

### Stablecoin depeg
Sometimes stable coins (which are supposed to always remain at the same value compared to an asset, which often is the US Dollar) can become depeged (detached) from this value leading to them being worth significantly more or less then the underlying asset. This can lead to severe problems in protocols that rely on stable coins being worth almost exactly the same as some asset. 

[Example](https://solodit.cyfrin.io/issues/hard-coded-_price-can-become-stale-and-inaccurate-in-the-event-of-a-depeg-quantstamp-ensuro-strategy-vault-markdown)
[Additional Reading](https://www.coinbase.com/learn/crypto-basics/why-do-stablecoins-depeg)