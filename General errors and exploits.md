
## Security measure implementation

### Is pausing implemented everywhere it should be 
If the protcol has a pausing functionality to block certain functions in case of an attack or other issue, check that the pause functions actually work, are implemented everywhere they should be and the docs state they are and also don't effect parts they shouldn't. In case of an async or cross chain protcol (bridge, VRF) make sure that both the first (origin, call) and second part (destination, callback) get paused.

Add later
[Example]()

## Reentrancy
### Classic Reentrancy
This vulnerability happens when, at some point during a function call, the user/attacker is called by the function (for example, through a native token transfer or a token contract with a hook) and the function doesn't follow the checks, effects, interactions pattern (CEI). Attackers can then either call the function again or another function in the protocol, for example, transfer their balance multiple times if the balance is  set to 0 only after the token is transferred to the withdrawing user. To mitigate this, add a `nonReentrant` modifier and/or follow the checks, effects, and interaction pattern.

[Example](https://solodit.cyfrin.io/issues/h-2-adversary-can-reenter-takeoverdebt-during-liquidation-to-steal-vault-funds-sherlock-real-wagmi-2-git)
[Further Reading](https://www.cyfrin.io/glossary/reentrancy)

### Read only Reentrancy
This exploit is similar to the classic reentrancy, but concerns read-only functions. The problem here is that a certain value is modified after an interaction happens, so that any function that relies on the un-updated value will receive incorrect data when getting it, for example, a smaller total supply. To mitigate this, add a `nonReentrant` modifier and/or follow the checks, effects, and interaction pattern.

[Example](https://solodit.cyfrin.io/issues/m-3-read-only-reentrancy-in-bondfixedtermteller-sherlock-bond-bond-protocol-git)

## Gas inflation
### Unbound arrays
An unbound array where any user can add one or multiple entries through some protocol function can be filled with an extreme amount of entries either during regular operations or on purpose by an attacker, which will cause any iteration over the array to exceed the block gas limit and cause a DOS. To mitigate this, use different storage types or limit entries to the array in some way.

[Example](https://solodit.cyfrin.io/issues/m-05-attacker-can-partially-dos-l1-operations-in-stakingmanager-by-making-huge-number-of-deposits-code4rena-kinetiq-kinetiq-git)

## Signatures and ECDSA recover
### Replay attack
The same signed transaction can be repeated multiple times when no user-specific nonce is used in the message. This can cause unwanted transfers of user or protocol funds that are potentially not reversible. To mitigate this, simply add an increasing user-specific nonce to the signed message to make sure each message is only used once
[Example](https://solodit.cyfrin.io/issues/m-3-signature-replay-attack-possible-on-updateworkerdeploymentconfigwithsig-in-blueprintcoresol-which-leads-to-users-lose-the-funds-sherlock-crestal-network-git)

## Price manipulation
### Stablecoin depeg
Sometimes stable coins (which are supposed to always remain at the same value compared to an asset, which often is the US Dollar) can become depeged (detached) from this value leading to them being worth significantly more or less then the underlying asset. This can lead to severe problems in protocols that rely on stable coins being worth almost exactly the same as some asset. 

[Example](https://solodit.cyfrin.io/issues/hard-coded-_price-can-become-stale-and-inaccurate-in-the-event-of-a-depeg-quantstamp-ensuro-strategy-vault-markdown)
[Additional Reading](https://www.coinbase.com/learn/crypto-basics/why-do-stablecoins-depeg)

## Low level
### Overflow/Underflow
Since version 0.8, solidity implements underflow and overflow checks by default. When a smaller integer over- or underflows, solidity will revert by default. This can be used by an attacker to cause a DOS. Some protocols use unchecked assembly blocks to save gas; inside these blocks, an overflow or underflow can still happen and cause severe problems.

[Example](https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/186)
[Additional Reading](https://cryptoguide.dev/post/solidity-assembly-guide/)

### Missing storage gaps
When a contract is supposed to be upgradeable is inherited by another contract, its important to reserve a storage gab in so that adding additional storage slots to the base contract in the future wont cause a storage collision in the child contract. Add an array as a gab at the end of the currently used storage variables to mitigate this

[Example](https://solodit.cyfrin.io/issues/missing-gap-to-avoid-storage-collisions-zokyo-none-symbiosis-markdown)
[Further reading](https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable#storage-gaps)

